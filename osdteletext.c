/*************************************************************** -*- c++ -*-
 *       Copyright (c) 2003,2004 by Marcel Wiesweg                         *
 *       (autogenerated code (c) Klaus Schmidinger)                        *
 *       Copyright (c) 2021      by Peter Bieringer (extenions)            *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#include <vdr/plugin.h>
#include <vdr/keys.h>
#include <vdr/config.h>

#include <getopt.h>
#include <iostream>

using namespace std;

#include "menu.h"
#include "txtrecv.h"
#include "setup.h"
#include "legacystorage.h"
#include "packedstorage.h"
#include "logging.h"

#if defined(APIVERSNUM) && APIVERSNUM < 10739
#error "VDR-1.7.39 API version or greater is required!"
#endif

#define NUMELEMENTS(x) (sizeof(x) / sizeof(x[0]))

static const char *VERSION        = "2.2.0.alpha.1";
static const char *DESCRIPTION    = trNOOP("Displays teletext on the OSD");
static const char *MAINMENUENTRY  = trNOOP("Teletext");

unsigned int m_debugmask = 0;
unsigned int m_debugpage = 0;
unsigned int m_debugpsub = 0;
int maxHotkeyLevel = 1;
int m_debugline = -1;

class cPluginTeletextosd : public cPlugin {
private:
  // Add any member variables or functions you may need here.
  cTxtStatus *txtStatus;
  bool startReceiver;
  bool storeTopText;
  Storage *storage;
  int maxStorage;
  void initTexts();
  Storage::StorageSystem storageSystem;
public:
  cPluginTeletextosd(void);
  virtual ~cPluginTeletextosd();
  virtual const char *Version(void) { return VERSION; }
  virtual const char *Description(void) { return tr(DESCRIPTION); }
  virtual const char *CommandLineHelp(void);
  virtual bool ProcessArgs(int argc, char *argv[]);
  virtual bool Start(void);
  virtual void Stop(void);
  virtual void Housekeeping(void);
  virtual const char *MainMenuEntry(void);
  virtual cOsdObject *MainMenuAction(void);
  virtual cMenuSetupPage *SetupMenu(void);
  virtual bool SetupParse(const char *Name, const char *Value);
};

class cTeletextSetupPage;
class ActionEdit {
   public:
      void Init(cTeletextSetupPage*, int, cMenuEditIntItem  *, cMenuEditStraItem *);
      void Init(cTeletextSetupPage*, int, int, bool, cMenuEditIntItem  *, cMenuEditStraItem *);
      cMenuEditStraItem *action;
      cMenuEditIntItem  *number;
   };

struct ActionKeyName {
   const char *internalName;
   const char *userName;
};

class cTeletextSetupPage : public cMenuSetupPage {
friend class ActionEdit;
private:
   TeletextSetup temp;
   int hotkeyLevel;
   int tempPageNumber[LastActionKey];
   int tempPageNumberHotkey[LastActionHotkey][HOTKEY_LEVEL_MAX_LIMIT];
   int tempConfiguredClrBackground; //must be a signed int
   cOsdItem *menuSectionKeysItem;
   cOsdItem *hotkeyLevelMaxItem;
   cOsdItem *hotkeyLevelItem;
protected:
   virtual void Store(void);
   ActionEdit ActionEdits[LastActionKey];
   ActionEdit ActionEditsHotkey[LastActionHotkey][HOTKEY_LEVEL_MAX_LIMIT];
   void SetupRefreshKeys(void);
   void SetupRefreshHotkeys(void);
   virtual eOSState ProcessKey(eKeys Key);
public:
   cTeletextSetupPage(void);
   static const ActionKeyName *actionKeyNames;
   static const ActionKeyName *actionHotkeyNames;
   static const char **modes;
   //~cTeletextSetupPage(void);
   //void SetItemVisible(cOsdItem *Item, bool visible, bool callDisplay=false);
};

const ActionKeyName *cTeletextSetupPage::actionKeyNames = 0;
const ActionKeyName *cTeletextSetupPage::actionHotkeyNames = 0;
const char **cTeletextSetupPage::modes = 0;

/*class MenuEditActionItem : public cMenuEditStraItem {
public:
   MenuEditActionItem(cTeletextSetupPage *parentMenu, cMenuEditIntItem *pageNumberMenuItem,
                           const char *Name, int *Value, int NumStrings, const char * const *Strings);
protected:
   virtual eOSState ProcessKey(eKeys Key);
   cTeletextSetupPage *parent;
   cMenuEditIntItem *pageNumberItem;
};*/


cPluginTeletextosd::cPluginTeletextosd(void)
  : txtStatus(0), startReceiver(true), storage(NULL), maxStorage(-1)
    , storageSystem(Storage::StorageSystemPacked)
{
  // Initialize any member variables here.
  // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
  // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
}

cPluginTeletextosd::~cPluginTeletextosd()
{
   // Clean up after yourself!
}

const char *cPluginTeletextosd::CommandLineHelp(void)
{
  // Return a string that describes all known command line options.
  return "  -d        --directory=DIR    The directory where the temporary files will be stored.\n"
         "                                default: /var/cache/vdr/vtx\n"
         "                                Ensure that the directory exists and is writable.\n"
         "  -n        --max-cache=NUM    Maximum size in megabytes of cache used\n"
         "                                to store the pages on the harddisk.\n"
         "                                default: a calculated value below 50 MB\n"
         "  -s        --cache-system=SYS Set the cache system to be used.\n"
         "                                Choose \"legacy\" for the traditional\n"
         "                                 one-file-per-page system.\n"
         "                                Default is \"packed\" for the \n"
         "                                 one-file-for-a-few-pages system.\n"
         "  -t,       --toptext          Store top text pages at cache. (unviewable pages)\n"
         "  -k        --key-levels=NUM   Maximum amount of Hotkey levels selectable and stored\n"
         "                                default: 1 (which deactivate this feature)\n"
         "                                maximum: " HOTKEY_LEVEL_MAX_LIMIT_STRING " levels\n"
         "  -P|--debugpage <int|hexint>  Specify page to debug (int: autoconvert internally to hex)\n"
         "  -S|--debugpsub <int|hexint>  Specify sub-page to debug (int: autoconvert internally to hex)\n"
         "  -L|--debugline <int>         Specify line of page to debug\n"
         "  -D|--debugmask <int|hexint>  Enable debugmask (see logging.h for details)\n";
}

bool cPluginTeletextosd::ProcessArgs(int argc, char *argv[])
{
  // Implement command line argument processing here if applicable.
   static struct option long_options[] = {
       { "directory",    required_argument,       NULL, 'd' },
       { "max-cache",    required_argument,       NULL, 'n' },
       { "cache-system", required_argument,       NULL, 's' },
       { "toptext",      no_argument,             NULL, 't' },
       { "hotkey-levels",required_argument,       NULL, 'k' },
       { "debugmask",    required_argument,       NULL, 'D' },
       { "debugpage",    required_argument,       NULL, 'P' },
       { "debugpsub",    required_argument,       NULL, 'S' },
       { "debugline",    required_argument,       NULL, 'L' },
       { NULL }
       };

   int c;
   while ((c = getopt_long(argc, argv, "k:s:d:n:tD:", long_options, NULL)) != -1) {
        switch (c) {
          case 's':
                    if (!optarg)
                       break;
                    if (strcasecmp(optarg, "legacy")==0)
                       storageSystem = Storage::StorageSystemLegacy;
                    else if (strcasecmp(optarg, "packed")==0)
                       storageSystem = Storage::StorageSystemPacked;
                    break;
          case 'd': Storage::setRootDir(optarg);
                    break;
          case 'n': if (isnumber(optarg)) {
                       int n = atoi(optarg);
                       maxStorage=n;
                    }
                    break;
          case 't': storeTopText=true;
                    break;
          case 'k': if (isnumber(optarg)) {
                       int n = atoi(optarg);
                       if ((n >= 1) && (n <= HOTKEY_LEVEL_MAX_LIMIT)) {
                          maxHotkeyLevel = n;
                       } else {
                          esyslog("osdteletext: maximum key-level value out-of-range 1..%d (skip): %s", HOTKEY_LEVEL_MAX_LIMIT, optarg);
                       };
                    }
                    break;
          case 'D':
            if ((strlen(optarg) > 2) && (strncasecmp(optarg, "0x", 2) == 0)) {
               // hex conversion
               if (sscanf(optarg + 2, "%x", &m_debugmask) == 0) {
                  esyslog("osdteletext: can't parse hexadecimal debug mask (skip): %s", optarg);
               };
            } else {
				   m_debugmask = atoi(optarg);
            };
			   dsyslog("osdteletext: enable debug mask: %d (0x%02x)", m_debugmask, m_debugmask);
            break;

          case 'P':
            if ((strlen(optarg) > 2) && (strncasecmp(optarg, "0x", 2) == 0)) {
               // hex conversion
               if (sscanf(optarg + 2, "%x", &m_debugpage) == 0) {
                  esyslog("osdteletext: can't parse hexadecimal debug page (skip): %s", optarg);
               };
            } else {
               // hex conversion
               if (sscanf(optarg, "%x", &m_debugpage) == 0) {
                  esyslog("osdteletext: can't parse hexadecimal debug page (skip): %s", optarg);
               };
            };
			   dsyslog("osdteletext: enable debug page: %03x", m_debugpage);
            break;

          case 'S':
            if ((strlen(optarg) > 2) && (strncasecmp(optarg, "0x", 2) == 0)) {
               // hex conversion
               if (sscanf(optarg + 2, "%x", &m_debugpsub) == 0) {
                  esyslog("osdteletext: can't parse hexadecimal debug sub-page (skip): %s", optarg);
               };
            } else {
               // hex conversion
               if (sscanf(optarg, "%x", &m_debugpsub) == 0) {
                  esyslog("osdteletext: can't parse hexadecimal debug sub-page (skip): %s", optarg);
               };
            };
			   dsyslog("osdteletext: enable debug sub-page: %03x", m_debugpsub);
            break;

          case 'L':
            m_debugline = atoi(optarg);
			   dsyslog("osdteletext: enable debug page line: %d", m_debugline);
            break;
        }
   }
   return true;
}

bool cPluginTeletextosd::Start(void)
{
   // Start any background activities the plugin shall perform.
   //Clean any files which might be remaining from the last session,
   //perhaps due to a crash they have not been deleted.
   switch (storageSystem) {
      case Storage::StorageSystemLegacy:
         isyslog("osdteletext: selected storage system: legacy");
         storage = new LegacyStorage(maxStorage);
         break;
      case Storage::StorageSystemPacked:
      default:
         isyslog("osdteletext: selected storage system: packed");
         storage = new PackedStorage(maxStorage);
         break;
   }

   initTexts();
   if (startReceiver)
      txtStatus=new cTxtStatus(storeTopText, storage);
#define SETUP_MIN_MAX_CHECK(value, min, max) \
   if (value < min) value = min; \
   if (value > max) value = max;

   SETUP_MIN_MAX_CHECK(ttSetup.OSDwidthPct , OSDwidthPctMin , OSDwidthPctMax )
   SETUP_MIN_MAX_CHECK(ttSetup.OSDheightPct, OSDheightPctMin, OSDheightPctMax)
   SETUP_MIN_MAX_CHECK(ttSetup.OSDleftPct  , OSDleftPctMin  , OSDleftPctMax  )
   SETUP_MIN_MAX_CHECK(ttSetup.OSDtopPct   , OSDtopPctMin   , OSDtopPctMax   )
   SETUP_MIN_MAX_CHECK(ttSetup.OSDframePix , OSDframePixMin , OSDframePixMax )
   SETUP_MIN_MAX_CHECK(ttSetup.txtVoffset  , txtVoffsetMin  , txtVoffsetMax  )

   // read available fonts into Vector
   cFont::GetAvailableFontNames(&ttSetup.txtFontNames, true);

   // run through available fonts backwards and delete blacklisted ones
   for (int i = ttSetup.txtFontNames.Size() -1;  i >= 0; i--) {
      if (    (strcasestr(ttSetup.txtFontNames[i], "Italic" ) != NULL)
           || (strcasestr(ttSetup.txtFontNames[i], "Oblique") != NULL)
      ) {
         DEBUG_OT_FONT("available font='%s' BLACKLISTED", ttSetup.txtFontNames[i]);
         ttSetup.txtFontNames.Remove(i);
      } else {
         DEBUG_OT_FONT("available font='%s' WHITELISTED", ttSetup.txtFontNames[i]);
      };
   };

   // display selectable fonts
   for (int i = 0; i < ttSetup.txtFontNames.Size(); i++) {
      DEBUG_OT_FONT("selectable font[%d]='%s'", i, ttSetup.txtFontNames[i]);
   };

   // find configured font and map into index value
   ttSetup.txtFontIndex = ttSetup.txtFontNames.Find(ttSetup.txtFontName);
   if (ttSetup.txtFontIndex < 0) {
       ttSetup.txtFontIndex = 0;
   }

   if (maxHotkeyLevel > 1)
      isyslog("osdteletext: OSD menu Hotkey multi-level feature enabled with maximum of levels: %d", maxHotkeyLevel);
   else
      isyslog("osdteletext: OSD menu Hotkey multi-level feature not activated");

   return true;
}

void cPluginTeletextosd::Stop(void)
{
   // store potentially changed values TODO detect real change
   SetupStore("OSDheightPct", ttSetup.OSDheightPct);
   SetupStore("OSDwidthPct", ttSetup.OSDwidthPct);
   SetupStore("OSDtopPct", ttSetup.OSDtopPct);
   SetupStore("OSDleftPct", ttSetup.OSDleftPct);
   SetupStore("OSDframePix", ttSetup.OSDframePix);
   SetupStore("hotkeyLevelMax", ttSetup.hotkeyLevelMax);
   SetupStore("txtFontName", ttSetup.txtFontName);
   SetupStore("txtVoffset", ttSetup.txtVoffset);
   SetupStore("lineMode24", ttSetup.lineMode24);
   SetupStore("configuredClrBackground", (int)(ttSetup.configuredClrBackground >> 24));

   DELETENULL(txtStatus);
   if (storage) {
      storage->cleanUp();
      DELETENULL(storage);
   }
}

void cPluginTeletextosd::initTexts() {
   if (cTeletextSetupPage::actionKeyNames)
      return;

   static const ActionKeyName st_actionKeyNames[] =
   {
      { "Action_kPlay",     trVDR("Key$Play") },
      { "Action_kStop",     trVDR("Key$Stop") },
      { "Action_kFastRew",  trVDR("Key$FastRew") },
      { "Action_kFastFwd",  trVDR("Key$FastFwd") },
      { "Action_kOk",       trVDR("Key$Ok") },
   };

   cTeletextSetupPage::actionKeyNames = st_actionKeyNames;


   static const ActionKeyName st_actionHotkeyNames[] =
   {
      { "Action_kRed",      trVDR("Key$Red") },
      { "Action_kGreen",    trVDR("Key$Green") },
      { "Action_kYellow",   trVDR("Key$Yellow") },
      { "Action_kBlue",     trVDR("Key$Blue") },
   };

   cTeletextSetupPage::actionHotkeyNames = st_actionHotkeyNames;


   static const char *st_modes[] =
   {
      // 1:1 relation between st_modes[] in osdteletext.c + eTeletextAction in setup.h + st_modesFooter in setup.c
      tr("Zoom"),
      tr("Half page"),
      tr("Change channel"),
      tr("Switch background"),
      //tr("Suspend receiving"),
      tr("Config"),
      tr("24-LineMode"),
      tr("Answer"),
      tr("Pause"),
      tr("Hotkey Level+"),
      tr("Hotkey Level-"),
      tr("Jump to...") // has to stay always as the last one
   };

   cTeletextSetupPage::modes = st_modes;
}

void cPluginTeletextosd::Housekeeping(void)
{
  // Perform any cleanup or other regular tasks.
}

const char *cPluginTeletextosd::MainMenuEntry(void)
{
   return ttSetup.HideMainMenu ? 0 : tr(MAINMENUENTRY);
}

cOsdObject *cPluginTeletextosd::MainMenuAction(void)
{
   // Perform the action when selected from the main VDR menu.
   return new TeletextBrowser(txtStatus,storage);
}

cMenuSetupPage *cPluginTeletextosd::SetupMenu(void)
{
  // Return a setup menu in case the plugin supports one.
  return new cTeletextSetupPage;
}


bool cPluginTeletextosd::SetupParse(const char *Name, const char *Value)
{
  initTexts();
  // Parse your own setup parameters and store their values.
  if (!strcasecmp(Name, "configuredClrBackground")) ttSetup.configuredClrBackground=( ((unsigned int)atoi(Value)) << 24);
  else if (!strcasecmp(Name, "showClock")) ttSetup.showClock=atoi(Value);
     //currently not used
  else if (!strcasecmp(Name, "suspendReceiving")) ttSetup.suspendReceiving=atoi(Value);
  else if (!strcasecmp(Name, "autoUpdatePage")) ttSetup.autoUpdatePage=atoi(Value);
  else if (!strcasecmp(Name, "OSDheightPct")) ttSetup.OSDheightPct=atoi(Value);
  else if (!strcasecmp(Name, "OSDwidthPct")) ttSetup.OSDwidthPct=atoi(Value);
  else if (!strcasecmp(Name, "OSDtopPct")) ttSetup.OSDtopPct=atoi(Value);
  else if (!strcasecmp(Name, "OSDleftPct")) ttSetup.OSDleftPct=atoi(Value);
  else if (!strcasecmp(Name, "OSDframePix")) ttSetup.OSDframePix=atoi(Value);
  else if (!strcasecmp(Name, "inactivityTimeout")) /*ttSetup.inactivityTimeout=atoi(Value)*/;
  else if (!strcasecmp(Name, "HideMainMenu")) ttSetup.HideMainMenu=atoi(Value);
  else if (!strcasecmp(Name, "txtFontName")) ttSetup.txtFontName=strdup(Value);
  else if (!strcasecmp(Name, "txtG0Block")) ttSetup.txtG0Block=atoi(Value);
  else if (!strcasecmp(Name, "txtG2Block")) ttSetup.txtG2Block=atoi(Value);
  else if (!strcasecmp(Name, "txtVoffset")) ttSetup.txtVoffset=atoi(Value);
  else if (!strcasecmp(Name, "colorMode4bpp")) ttSetup.colorMode4bpp=atoi(Value);
  else if (!strcasecmp(Name, "lineMode24")) ttSetup.lineMode24=atoi(Value);
  // ignore obsolete options
#define DSYSLOG_IGNORE_OPTION dsyslog("osdteletext: ignore obsolete option in setup.conf: osdteletext.%s", Name);
  else if (!strcasecmp(Name, "OSDHAlign"  )) { DSYSLOG_IGNORE_OPTION } // < 1.0.0
  else if (!strcasecmp(Name, "OSDVAlign"  )) { DSYSLOG_IGNORE_OPTION } // < 1.0.0
  else if (!strcasecmp(Name, "OSDheight"  )) { DSYSLOG_IGNORE_OPTION } // < 1.0.0
  else if (!strcasecmp(Name, "OSDwidth"   )) { DSYSLOG_IGNORE_OPTION } // < 1.0.0
  else if (!strcasecmp(Name, "OSDhcentPct")) { DSYSLOG_IGNORE_OPTION } // 1.0.0 - 1.0.4
  else if (!strcasecmp(Name, "OSDvcentPct")) { DSYSLOG_IGNORE_OPTION } // 1.0.0 - 1.0.4
  else if (!strcasecmp(Name, "OSDframePct")) { DSYSLOG_IGNORE_OPTION } // > 1.0.6 && < 1.0.7
  else if (!strcasecmp(Name, "hotkeyLevelMax")) {
     ttSetup.hotkeyLevelMax = atoi(Value);
     if (ttSetup.hotkeyLevelMax > maxHotkeyLevel) {
        // limit by command line option maximum
        ttSetup.hotkeyLevelMax = maxHotkeyLevel;
     } else if (ttSetup.hotkeyLevelMax < 1) {
        // minimum is 1
        ttSetup.hotkeyLevelMax = 1;
     };
  }
  else {
     for (int i=0;i<LastActionKey;i++) {
        if (!strcasecmp(Name, cTeletextSetupPage::actionKeyNames[i].internalName)) {
           ttSetup.mapKeyToAction[i]=(eTeletextAction)atoi(Value);
           return true;
        }
     }

     // parse setup related to Hotkey with levels
     for (int i = 0; i < LastActionHotkey; i++) {
        if (! strcasecmp(Name, cTeletextSetupPage::actionHotkeyNames[i].internalName)) {
           // backwards compatibility
           DEBUG_OT_SETUP("Hotkey (menu level ==1) config found: %s (Name=%s)\n", cTeletextSetupPage::actionHotkeyNames[i].internalName, Name);
           // level 0 has no suffix for compatibility reason
           ttSetup.mapHotkeyToAction[i][0]=(eTeletextAction)atoi(Value);
           return true;
        };

        if (! strncasecmp(Name, cTeletextSetupPage::actionHotkeyNames[i].internalName, strlen(cTeletextSetupPage::actionHotkeyNames[i].internalName))) {;
           if ((strlen(Name) - 1) != strlen(cTeletextSetupPage::actionHotkeyNames[i].internalName)) {
              // invalid option, only 1 digit is supported
              return false;
           }

           // extract level suffix
           int l = atoi(Name+strlen(cTeletextSetupPage::actionHotkeyNames[i].internalName)) - 1; // last char digit
           if ((l < 0) || (l >= HOTKEY_LEVEL_MAX_LIMIT)) {
              // ignore out-of-range suffix
              esyslog("osdteletext: ignore out-of-range menu level related option in setup.conf: osdteletext.%s (detected level=%d)", Name, l);
              return false;
           };

           DEBUG_OT_SETUP("Hotkey (menu level > 1) config found: %s%d (Name=%s)\n", cTeletextSetupPage::actionHotkeyNames[i].internalName, l, Name);
           ttSetup.mapHotkeyToAction[i][l] = (eTeletextAction)atoi(Value);
           if (ttSetup.mapHotkeyToAction[i][l] > LastAction)
              // failsafe mapping
              ttSetup.mapHotkeyToAction[i][l] = (eTeletextAction) 100;
           return true;
        } else {
           // DEBUG_OT_SETUP("Hotkey (menu level > 1) config NOT found: %s* (Name=%s)\n", cTeletextSetupPage::actionHotkeyNames[i].internalName, Name);
        }
     }

     return false;
  }
  return true;
}


void cTeletextSetupPage::Store(void) {
   //copy table
   for (int i=0;i<LastActionKey;i++) {
      if (temp.mapKeyToAction[i] >= LastAction) //jump to page selected
         ttSetup.mapKeyToAction[i]=(eTeletextAction)tempPageNumber[i];
      else //one of the other modes selected
         ttSetup.mapKeyToAction[i]=temp.mapKeyToAction[i];
   }

   // copy Hotkey table
   for (int l = 0; l < HOTKEY_LEVEL_MAX_LIMIT; l++) {
      for (int i = 0;i < LastActionHotkey; i++) {
         if (temp.mapHotkeyToAction[i][l] >= LastAction) //jump to page selected
            ttSetup.mapHotkeyToAction[i][l] = (eTeletextAction)tempPageNumberHotkey[i][l];
         else //one of the other modes selected
            ttSetup.mapHotkeyToAction[i][l] = temp.mapHotkeyToAction[i][l];
      }
   }

   ttSetup.configuredClrBackground=( ((unsigned int)tempConfiguredClrBackground) << 24);
   ttSetup.showClock=temp.showClock;
   ttSetup.suspendReceiving=temp.suspendReceiving;
   ttSetup.autoUpdatePage=temp.autoUpdatePage;
   ttSetup.OSDheightPct=temp.OSDheightPct;
   ttSetup.OSDwidthPct=temp.OSDwidthPct;
   ttSetup.OSDtopPct=temp.OSDtopPct;
   ttSetup.OSDleftPct=temp.OSDleftPct;
   ttSetup.OSDframePix=temp.OSDframePix;
   ttSetup.hotkeyLevelMax=temp.hotkeyLevelMax;
   ttSetup.HideMainMenu=temp.HideMainMenu;
   ttSetup.txtFontName=ttSetup.txtFontNames[temp.txtFontIndex];
   ttSetup.txtG0Block=temp.txtG0Block;
   ttSetup.txtG2Block=temp.txtG2Block;
   ttSetup.txtVoffset=temp.txtVoffset;
   ttSetup.colorMode4bpp=temp.colorMode4bpp;
   ttSetup.lineMode24=temp.lineMode24;
   //ttSetup.inactivityTimeout=temp.inactivityTimeout;

   for (int i=0;i<LastActionKey;i++) {
      SetupStore(actionKeyNames[i].internalName, ttSetup.mapKeyToAction[i]);
   }

   // store Hotkey table (maximum given by command line: maxHotkeyLevel)
   char str[40];
   for (int l = 0; l < maxHotkeyLevel; l++) {
      for (int i = 0; i < LastActionHotkey;i++) {
         if (l == 0) {
            // store Hotkey hotkeyLevel 1 in legacy format (backwards compatibility)
            SetupStore(actionHotkeyNames[i].internalName, ttSetup.mapHotkeyToAction[i][l]);
         } else {
            // store Hotkey hotkeyLevel > 1 with hotkeyLevel suffix (1 digit)
            snprintf(str, sizeof(str), "%s%d", actionHotkeyNames[i].internalName, l + 1);
            SetupStore(str, ttSetup.mapHotkeyToAction[i][l]);
         };
      };
   }

   SetupStore("configuredClrBackground", (int)(ttSetup.configuredClrBackground >> 24));
   SetupStore("showClock", ttSetup.showClock);
      //currently not used
   //SetupStore("suspendReceiving", ttSetup.suspendReceiving);
   SetupStore("autoUpdatePage", ttSetup.autoUpdatePage);
   SetupStore("OSDheightPct", ttSetup.OSDheightPct);
   SetupStore("OSDwidthPct", ttSetup.OSDwidthPct);
   SetupStore("OSDtopPct", ttSetup.OSDtopPct);
   SetupStore("OSDleftPct", ttSetup.OSDleftPct);
   SetupStore("OSDframePix", ttSetup.OSDframePix);
   SetupStore("hotkeyLevelMax", ttSetup.hotkeyLevelMax);
   SetupStore("HideMainMenu", ttSetup.HideMainMenu);
   SetupStore("txtFontName", ttSetup.txtFontName);
   SetupStore("txtG0Block", ttSetup.txtG0Block);
   SetupStore("txtG2Block", ttSetup.txtG2Block);
   SetupStore("txtVoffset", ttSetup.txtVoffset);
   SetupStore("colorMode4bpp", ttSetup.colorMode4bpp);
   SetupStore("lineMode24", ttSetup.lineMode24);
   //SetupStore("inactivityTimeout", ttSetup.inactivityTimeout);
}

cTeletextSetupPage::cTeletextSetupPage(void) {
   cString buf;
   cOsdItem *item;

   temp.txtBlock[0]  = tr("Latin 1");
   temp.txtBlock[1]  = tr("Latin 2");
   temp.txtBlock[2]  = tr("Latin 3");
   temp.txtBlock[3]  = tr("Latin 4");
   temp.txtBlock[4]  = tr("Cyrillic");
   temp.txtBlock[5]  = tr("Reserved");
   temp.txtBlock[6]  = tr("Greek");
   temp.txtBlock[7]  = tr("Reserved");
   temp.txtBlock[8]  = tr("Arabic");
   temp.txtBlock[9]  = tr("Reserved");
   temp.txtBlock[10] = tr("Hebrew");

   hotkeyLevel = 1;
   temp.hotkeyLevelMax = ttSetup.hotkeyLevelMax;

   //init tables
   for (int i=0;i<LastActionKey;i++) {
      if (ttSetup.mapKeyToAction[i] >= LastAction) {//jump to page selected
         temp.mapKeyToAction[i]=LastAction; //to display the last string
         tempPageNumber[i]=ttSetup.mapKeyToAction[i];
      } else { //one of the other modes selected
         temp.mapKeyToAction[i]=ttSetup.mapKeyToAction[i];
         tempPageNumber[i]=100;
      }
   }

   // init Hotkey tables
   for (int l = 0; l < HOTKEY_LEVEL_MAX_LIMIT; l++) {
      for (int i = 0; i < LastActionHotkey; i++) {
         if (ttSetup.mapHotkeyToAction[i][l] >= LastAction) {//jump to page selected
            temp.mapHotkeyToAction[i][l] = LastAction; //to display the last string
            tempPageNumberHotkey[i][l] = ttSetup.mapHotkeyToAction[i][l];
         } else { //one of the other modes selected
            temp.mapHotkeyToAction[i][l] = ttSetup.mapHotkeyToAction[i][l];
            tempPageNumberHotkey[i][l] = 100;
         }
      }
   }

   tempConfiguredClrBackground=(ttSetup.configuredClrBackground >> 24);
   temp.showClock=ttSetup.showClock;
   temp.suspendReceiving=ttSetup.suspendReceiving;
   temp.autoUpdatePage=ttSetup.autoUpdatePage;
   temp.OSDheightPct=ttSetup.OSDheightPct;
   temp.OSDwidthPct=ttSetup.OSDwidthPct;
   temp.OSDtopPct=ttSetup.OSDtopPct;
   temp.OSDleftPct=ttSetup.OSDleftPct;
   temp.OSDframePix=ttSetup.OSDframePix;
   temp.hotkeyLevelMax=ttSetup.hotkeyLevelMax;
   temp.HideMainMenu=ttSetup.HideMainMenu;
   temp.txtFontName=ttSetup.txtFontName;
   temp.txtG0Block=ttSetup.txtG0Block;
   temp.txtG2Block=ttSetup.txtG2Block;
   temp.txtVoffset=ttSetup.txtVoffset;
   temp.colorMode4bpp=ttSetup.colorMode4bpp;
   temp.lineMode24=ttSetup.lineMode24;
   //temp.inactivityTimeout=ttSetup.inactivityTimeout;

   temp.txtFontIndex = ttSetup.txtFontNames.Find(ttSetup.txtFontName);
   if (temp.txtFontIndex < 0) {
       temp.txtFontIndex = 0;
   }

   Add(new cMenuEditIntItem(tr("Background transparency"), &tempConfiguredClrBackground, 0, 255));

   Add(new cMenuEditBoolItem(tr("Show clock"), &temp.showClock ));

   //Add(new cMenuEditBoolItem(tr("Setup$Suspend receiving"), &temp.suspendReceiving ));

   Add(new cMenuEditBoolItem(tr("Auto-update pages"), &temp.autoUpdatePage ));
   Add(new cMenuEditIntItem(tr("OSD left (%)"), &temp.OSDleftPct, OSDleftPctMin, OSDleftPctMax));
   Add(new cMenuEditIntItem(tr("OSD top (%)"), &temp.OSDtopPct, OSDtopPctMin, OSDtopPctMax));
   Add(new cMenuEditIntItem(tr("OSD width (%)"), &temp.OSDwidthPct, OSDwidthPctMin, OSDwidthPctMax));
   Add(new cMenuEditIntItem(tr("OSD height (%)"), &temp.OSDheightPct, OSDheightPctMin, OSDheightPctMax));
   Add(new cMenuEditIntItem(tr("OSD frame pixel"), &temp.OSDframePix, OSDframePixMin, OSDframePixMax));
   Add(new cMenuEditBoolItem(tr("Hide mainmenu entry"), &temp.HideMainMenu));
   Add(new cMenuEditStraItem(tr("Text Font"), &temp.txtFontIndex, ttSetup.txtFontNames.Size(), &ttSetup.txtFontNames[0]));
   Add(new cMenuEditStraItem(tr("G0 code block"), &temp.txtG0Block, NUMELEMENTS(temp.txtBlock), temp.txtBlock));
   Add(new cMenuEditStraItem(tr("G2 code block"), &temp.txtG2Block, NUMELEMENTS(temp.txtBlock), temp.txtBlock));
   Add(new cMenuEditIntItem(tr("Text Vertical Offset"), &temp.txtVoffset, txtVoffsetMin, txtVoffsetMax));
   Add(new cMenuEditBoolItem(tr("16-Color Mode"), &temp.colorMode4bpp));
   Add(new cMenuEditBoolItem(tr("24-Line Mode"), &temp.lineMode24));

   //Using same string as VDR's setup menu
   //Add(new cMenuEditIntItem(tr("Setup.Miscellaneous$Min. user inactivity (min)"), &temp.inactivityTimeout));

   // Hotkey bindings
   if (maxHotkeyLevel > 1)
      buf = cString::sprintf("%s %s (%s %s %d/%d):", tr("Key bindings"), tr("Hotkey"), tr("max"), tr("Levels"), maxHotkeyLevel, HOTKEY_LEVEL_MAX_LIMIT);
   else
      buf = cString::sprintf("%s Hotkey:", tr("Key bindings"));
   item = new cOsdItem(*buf);
   item->SetSelectable(false);
   Add(item);

   if (maxHotkeyLevel > 1) {
      // maximum given by command line option: maxHotkeyLevel
      cString buf2 = cString::sprintf("OSD Hotkey %s %s", tr("Levels"), tr("visible"));
      hotkeyLevelMaxItem = new cMenuEditIntItem(buf2, &temp.hotkeyLevelMax, 1, maxHotkeyLevel);
      Add(hotkeyLevelMaxItem);

      cString buf3 = cString::sprintf("OSD Hotkey %s %s", tr("Level"), tr("Config"));
      hotkeyLevelItem = new cMenuEditIntItem(buf3, &hotkeyLevel, 1, temp.hotkeyLevelMax);
      Add(hotkeyLevelItem);
   } else {
      // hide option but remember for hook later the section entry from above
      hotkeyLevelItem = item;
   };

   for (int l = 0; l < maxHotkeyLevel; l++) {
      for (int i = 0; i < LastActionHotkey; i++) {
         ActionEditsHotkey[i][l].Init(this, i, l
            , (l == (hotkeyLevel - 1))
            , new cMenuEditIntItem(tr("  Page number"), &tempPageNumberHotkey[i][l], 100, 899)
            , new cMenuEditStraItem(actionHotkeyNames[i].userName, (int*)&temp.mapHotkeyToAction[i][l], LastAction+1, modes)
         );
      };
   }

   // Standard Key bindings
   buf = cString::sprintf("%s:", tr("Key bindings"));
   menuSectionKeysItem = new cOsdItem(*buf);
   menuSectionKeysItem->SetSelectable(false);
   Add(menuSectionKeysItem);

   for (int i=0;i<LastActionKey;i++) {
      ActionEdits[i].Init(this, i, new cMenuEditIntItem(tr("  Page number"), &tempPageNumber[i], 100, 899),
         new cMenuEditStraItem(actionKeyNames[i].userName, (int*)&temp.mapKeyToAction[i], LastAction+1, modes) );
   }
}

void cTeletextSetupPage::SetupRefreshKeys(void) {
   // recreate key setup without sophisticated and issue causing dynamic Insert+Add (e.g. last line 'Jump to' is not working)

   // delete all key entry if existing
   for (int i = 0; i < LastActionKey; i++) {
      if (cList<cOsdItem>::Contains(ActionEdits[i].action))
         cList<cOsdItem>::Del(ActionEdits[i].action, false);
      if (cList<cOsdItem>::Contains(ActionEdits[i].number))
         cList<cOsdItem>::Del(ActionEdits[i].number, false);
   };

   // add selected ones
   cOsdItem *hook = menuSectionKeysItem;
   for (int i = 0; i < LastActionKey; i++) {
      DEBUG_OT_KEYS("key assigment menu i=%d action=%d (main)", i, temp.mapKeyToAction[i]);
      Add(ActionEdits[i].action, false, hook);
      hook = ActionEdits[i].action;

      if (temp.mapKeyToAction[i] == LastAction) {
         // insert number if selected
         DEBUG_OT_KEYS("key assigment menu i=%d action=%d pagenumber=%d", i, temp.mapKeyToAction[i], tempPageNumber[i]);
         Add(ActionEdits[i].number, false, hook);
         hook = ActionEdits[i].number;
      };
   };
}

void cTeletextSetupPage::SetupRefreshHotkeys(void) {
   // recreate hot key setup without sophisticated and issue causing dynamic Insert+Add (e.g. last line 'Jump to' is not working)

   // Hotkey assignment
   int l = hotkeyLevel - 1;

   // delete all hot key entry if existing
   for (int l = 0; l < HOTKEY_LEVEL_MAX_LIMIT; l++) {
      for (int i = 0; i < LastActionHotkey; i++) {
         if (cList<cOsdItem>::Contains(ActionEditsHotkey[i][l].action))
            cList<cOsdItem>::Del(ActionEditsHotkey[i][l].action, false);
         if (cList<cOsdItem>::Contains(ActionEditsHotkey[i][l].number))
            cList<cOsdItem>::Del(ActionEditsHotkey[i][l].number, false);
      };
   };

   // add selected ones
   cOsdItem *hook = hotkeyLevelItem;
   for (int i = 0; i < LastActionHotkey; i++) {
      DEBUG_OT_KEYS("hot key assigment menu i=%d hotkeyLevel=%d action=%d (main)", i, hotkeyLevel, temp.mapHotkeyToAction[i][l]);
      Add(ActionEditsHotkey[i][l].action, false, hook);
      hook = ActionEditsHotkey[i][l].action;

      if (temp.mapHotkeyToAction[i][l] == LastAction) {
         // insert number if selected
         DEBUG_OT_KEYS("hot key assigment menu i=%d hotkeyLevel=%d action=%d pagenumber=%d", i, hotkeyLevel, temp.mapHotkeyToAction[i][l], tempPageNumberHotkey[i][l]);
         Add(ActionEditsHotkey[i][l].number, false, hook);
         hook = ActionEditsHotkey[i][l].number;
      };
   };

}

eOSState cTeletextSetupPage::ProcessKey(eKeys Key) {
   if (Key != kNone) DEBUG_OT_KEYS("called with Key=%d", Key);
   eOSState state = cMenuSetupPage::ProcessKey(Key);
   if (Key != kRight && Key!=kLeft)
      return state;
   cOsdItem *item = Get(Current());

   if (item == hotkeyLevelMaxItem) {
      // change of OSD menu level max
      DEBUG_OT_KEYS("hotkeyLevelMaxItem changed hotkeyLevelMax=%d (hotkeyLevel=%d)", temp.hotkeyLevelMax, hotkeyLevel);

      if (hotkeyLevel > temp.hotkeyLevelMax) {
         hotkeyLevel = temp.hotkeyLevelMax;
         // recreate Hotkey with reduced hotkeyLevel (e.g. switch from >max to max
         SetupRefreshHotkeys();
      };

      // replace entry with new maximum
      cList<cOsdItem>::Del(hotkeyLevelItem);
      hotkeyLevelItem = new cMenuEditIntItem(tr("OSD Hotkey Level"), &hotkeyLevel, 1, temp.hotkeyLevelMax);
      Add(hotkeyLevelItem, false, hotkeyLevelMaxItem);

      Display();
      return state;
   };

   if (item == hotkeyLevelItem) {
      // change between menu levels
      DEBUG_OT_KEYS("hotkeyLevelItem changed OSDhotkeyLevel=%d", hotkeyLevel);
      SetupRefreshHotkeys();
      Display();
      return state;
   };

   // Standard Key change handling for 'Jump to'
   for (int i=0;i<LastActionKey;i++) {
      if (ActionEdits[i].action==item) { //we have a key left/right and one of our items as current
         SetupRefreshKeys();
         Display();
      }
   }

   // Hotkey change handling for 'Jump to'
   int l = hotkeyLevel - 1;
   for (int i=0; i < LastActionHotkey; i++) {
      DEBUG_OT_KEYS("hot key assigment menu i=%d hotkeyLevel=%d action=%d (pagenumber)", i, hotkeyLevel, temp.mapHotkeyToAction[i][l]);
      if (ActionEditsHotkey[i][l].action == item) { //we have a key left/right and one of our items as current
         SetupRefreshHotkeys();
         Display();
      };
   };

   return state;
   //return cMenuSetupPage::ProcessKey(Key);
}


void ActionEdit::Init(cTeletextSetupPage* s, int num, cMenuEditIntItem  *p, cMenuEditStraItem * a) {
   action=a;
   number=p;
   s->Add(action);
   if (s->temp.mapKeyToAction[num] == LastAction) {
      s->Add(number);
   };
}

void ActionEdit::Init(cTeletextSetupPage* s, int num, int level, bool active, cMenuEditIntItem  *p, cMenuEditStraItem * a) {
   action=a;
   number=p;
   if (!active) return;
   s->Add(action);
   if (s->temp.mapHotkeyToAction[num][level] == LastAction) {
      s->Add(number);
   };
}


VDRPLUGINCREATOR(cPluginTeletextosd); // Don't touch this!

// vim: ts=3 sw=3 et
